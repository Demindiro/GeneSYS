x86-64 / x64 / AMD64 / IA32e
============================

The UEFI variant is intended for use on real hardware.
The BIOS variant is intended for use on "cloud" VPSes with no UEFI support.

At least 8MiB of physical memory is required to be usable at all.
(first 2MiB reserved, 4MiB for the kernel and 2MiB for initial OS)


Supported hardware
------------------

- [ ] Memory
- [ ] MMU
- [ ] APIC
- [ ] HPET
- [x] UART (COM1/COM2)
- [ ] PCI / PCIe


Boot
----

On boot, a 2MiB code and 2MiB data page is mapped in the negative half.
The code page also contains the initial page table and memory map.
It is entirely immutable.
The page table does *not* include an identity mapping.

The kernel starts running from the start of the codepage.
It clears the data region with zeros, sets up the GDT, IDT and a new page table.


Initial OS
----------

The kernel loads an OS at boot.
This can be a full-fledged OS or a simple stub.

An address space is created with the following ranges defined:

- `0x3f000000` until `0x3f200000`: page table (R)
- `0x3fe00000` until `0x40000000`: OS code (RWX)

The initial OS code is limited to at most 2MiB,
but the real limit is even lower.
Extra code should be loaded by the OS.

The page table provides read-only access to the paging structure
currently in use. Updates can only be done through system calls.


System calls
------------

System calls are performed through the `syscall` instruction.
`eax` is used to identify the system routine.
The registers used depend on the routine.
`rcx` and `r11` are always clobbered.

System calls may use SSE registers,
but will save and restore them as appropriate.

Unless noted otherwise general purpose registers are always preserved.

If an invalid system call is issued, the OS is immediately halted.

### 1. Syslog

arguments: address in RSI, length in RDX.

returns: amount written in RAX.

### 2. Halt

arguments: none

returns: technically never.
In practice it is up to the interrupt handler,
so do not add any `noreturn` attributes.

### 3. Identify

arguments: none

returns: "GeneSYS" in RAX, `0x20260130` in RDX.


(Physical) memory allocation
----------------------------

By default, memory is divided in pages of 2MiB.
All memory allocations use whole 2MiB pages.
This makes it more convenient to use 2M pages in many places,
improving TLB performance.

It is likely many 4KiB pages are inaccessible by default with this scheme,
but this is not expected to be a significant issue.

Pages are only referenced in pages tables.
Pages can be referenced an arbitrary amount of times.

The allocation status of a page is tracked with a single bit.

Allocated pages are always recorded in the page table (even if unused/"not present").
Addresses of 4K pages are masked to refer to the containing 2M page.

To avoid needing to scan a potentially very large array (see table below)
pages are grouped in sets of 1024 entries, each set having a 16-bit counter
indicating the number of free pages.

Additionaly, there are supersets of 32 sets each, each superset having
a 16-bit counter indicating the number of free pages.

### Tracing versus reference counting

Tracing GC is chosen because:

- It entirely avoids permanent resource leaks.
- It can seamlessly handle cyclic references.
- It potentially allows higher throughput by avoid random accesses to counters.

### Physical memory in bytes compared to page, set and superset count

| total physical memory | pages | sets | supersets |
| ---------------------:| -----:| ----:| ---------:|
|                   16M |     8 |    1 |         1 |
|                   32M |    16 |    1 |         1 |
|                   64M |    32 |    1 |         1 |
|                  128M |    64 |    1 |         1 |
|                  256M |   128 |    1 |         1 |
|                  512M |   256 |    1 |         1 |
|                    1G |   512 |    1 |         1 |
|                    2G |    1K |    1 |         1 |
|                    4G |    2K |    2 |         1 |
|                    8G |    4K |    4 |         1 |
|                   16G |    8K |    8 |         1 |
|                   32G |   16K |   16 |         1 |
|                   64G |   32K |   32 |         1 |
|                  128G |   64K |   64 |         2 |
|                  256G |  128K |  128 |         4 |
|                  512G |  256K |  256 |         8 |
|                    1T |  512K |  512 |        16 |
|                    2T |    1M |   1K |        32 |
|                    4T |    2M |   2K |        64 |
|                    8T |    4M |   4K |       128 |
|                   16T |    8M |   8K |       256 |

Currently, only a maximum of 16T memory is supported.
A different strategy or a "super-superset" is likely prefereable
at and above 4T, especially considering NUMA.

| total physical memory | pages | sets | supersets |
| ---------------------:| -----:| ----:| ---------:|
|                   32T |   16M |  16K |       512 |
|                   64T |   32M |  32K |        1K |
|                  128T |   64M |  64K |        2K |
|                  256T |  128M | 128K |        4K |
|                  512T |  256M | 256K |        8K |
|                    1P |  512M | 512K |       16K |
|                    2P |    1G |   1M |       32K |
|                    4P |    2G |   2M |       64K |

MMU
---

The page tables used by the MMU are managed by the kernel.
The kernel initially allocates a single 2MiB buffer for the page table,
but more can be allocated in 2MiB chunks.

An OS can create multiple address spaces for isolation,
but only the initial address space is used for exceptions.

`syscall`s executed in other address spaces are always redirected to the
initial address space.

An OS must allocate page tables and roots inside this buffer.
The page tables can always be read freely but modifications must go through
the kernel as arbitrary writes would compromise the security of the kernel.

To simplify security checks and avoid potential resource leaks,
the kernel uses a strict scheme:

- roots must be explicitly allocated (up to 512).
- parent page tables must be explicitly allocated.

The first root (0) is considered the default address space and used for
system calls in other address spaces.


System log
----------

The kernel provides a global system log which is writeable by all OSes.
It is a simple array of fixed-size log entries.

Each entry starts with a 64-bit header:

| bits  | description    |
| -----:|:-------------- |
|  15:0 | source         |
| 63:16 | timestamp (Âµs) |

The source refers to the OS which wrote the message.
Source 0 is reserved by the kernel.

Entries are all 64 bytes each, including the header.
They *should* be valid UTF-8 and are delimited by a zero-byte
or the maximum length, though this is not validated.


IOMMU
-----

The IOMMU is the equivalent of the MMU for all other devices on a platform.

Three IOMMU modes are supported:

- [ ] No IOMMU
- [ ] Intel VT-d
- [ ] AMD-VI

Both Intel VT-d and AMD-VI reuse the page table format of the MMU,
which makes it _almost_ trivial to give an OS and devices the same view of memory.

AMD-VI assigns meaning to all the AVL bits in the page table instead of reusing
existing bits. For this reason none of the AVL bits are free for use by the OS.

**No IOMMU is unsafe** as it does not restrict devices in any way,
but it is the only option guaranteed to work on all platforms.
Without IOMMU (or equivalent) it is not possible to present a shared
view between an OS and devices.
In this situation, the OS is responsible for translating addresses
(or setting up an identity map).
