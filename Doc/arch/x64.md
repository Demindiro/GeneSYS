x86-64 / x64 / AMD64 / IA32e
============================

Two types of kernels are provided:

- UEFI / BIOS compatible
- Unikernel (**TODO**)

The UEFI / BIOS kernel is intended for use on real hardware.

The unikernel is designed for "cloud" VPSes: small virtual machines
typically dedicated to a single application.

Only the UEFI/BIOS compatible kernels provide security and debugging tools.
The unikernel is designed to minimize overhead and to utilize debugging tools
provided by the hypervisor.

At least 10MiB of physical memory is required to be usable at all.
(first 2MiB reserved, 4MiB for the kernel and 4MiB for initial OS)


Supported hardware
------------------

- [ ] Memory
- [ ] MMU
- [ ] APIC
- [ ] HPET
- [x] UART (COM1/COM2)
- [ ] PCI / PCIe


Initial OS
----------

The kernel loads an OS at boot.
This can be a full-fledged OS or a simple stub.

An address space is created with the following ranges defined:

- `0x3f000000` until `0x3f200000`: page table (R)
- `0x3fe00000` until `0x40000000`: OS code (RWX)

The initial OS code is limited to at most 2MiB,
but the real limit is even lower.
Extra code should be loaded by the OS.

The page table provides read-only access to the paging structure
currently in use. Updates can only be done through system calls.


System calls
------------

To efficiently support unikernels,
direct usage of the `syscall` instruction is prohibited.
Instead, all calls are proxied through routines mapped at
a fixed location.

System calls may use SSE registers.
To avoid leaking data or needing to save registers,
`vzeroall` (or equivalent) is always called before returning.


(Physical) memory allocation
----------------------------

By default, memory is divided in pages of 2MiB.
All memory allocations use whole 2MiB pages.
This makes it more convenient to use 2M pages in many places,
improving TLB performance.

It is likely many 4KiB pages are inaccessible by default with this scheme,
but this is not expected to be a significant issue.

Pages are only referenced in pages tables.
Pages can be referenced an arbitrary amount of times.

The allocation status of a page is tracked with a single bit.

Allocated pages are always recorded in the page table (even if unused/"not present").
Addresses of 4K pages are masked to refer to the containing 2M page.

To avoid needing to scan a potentially very large array (see table below)
pages are grouped in sets of 1024 entries, each set having a 16-bit counter
indicating the number of free pages.

Additionaly, there are supersets of 32 sets each, each superset having
a 16-bit counter indicating the number of free pages.

### Tracing versus reference counting

Tracing GC is chosen because:

- It entirely avoids permanent resource leaks.
- It can seamlessly handle cyclic references.
- It potentially allows higher throughput by avoid random accesses to counters.

### Physical memory in bytes compared to page, set and superset count

| total physical memory | pages | sets | supersets |
| ---------------------:| -----:| ----:| ---------:|
|                   16M |     8 |    1 |         1 |
|                   32M |    16 |    1 |         1 |
|                   64M |    32 |    1 |         1 |
|                  128M |    64 |    1 |         1 |
|                  256M |   128 |    1 |         1 |
|                  512M |   256 |    1 |         1 |
|                    1G |   512 |    1 |         1 |
|                    2G |    1K |    1 |         1 |
|                    4G |    2K |    2 |         1 |
|                    8G |    4K |    4 |         1 |
|                   16G |    8K |    8 |         1 |
|                   32G |   16K |   16 |         1 |
|                   64G |   32K |   32 |         1 |
|                  128G |   64K |   64 |         2 |
|                  256G |  128K |  128 |         4 |
|                  512G |  256K |  256 |         8 |
|                    1T |  512K |  512 |        16 |
|                    2T |    1M |   1K |        32 |
|                    4T |    2M |   2K |        64 |
|                    8T |    4M |   4K |       128 |
|                   16T |    8M |   8K |       256 |

Currently, only a maximum of 16T memory is supported.
A different strategy or a "super-superset" is likely prefereable
at and above 4T, especially considering NUMA.

| total physical memory | pages | sets | supersets |
| ---------------------:| -----:| ----:| ---------:|
|                   32T |   16M |  16K |       512 |
|                   64T |   32M |  32K |        1K |
|                  128T |   64M |  64K |        2K |
|                  256T |  128M | 128K |        4K |
|                  512T |  256M | 256K |        8K |
|                    1P |  512M | 512K |       16K |
|                    2P |    1G |   1M |       32K |
|                    4P |    2G |   2M |       64K |

MMU
---

The page tables used by the MMU are managed by the kernel.
The kernel initially allocates a single 2MiB buffer for the page table,
but more can be allocated in 2MiB chunks.

An OS can create multiple address spaces for isolation,
but only the initial address space is used for exceptions.

`syscall`s executed in other address spaces are always redirected to the
initial address space.

An OS must allocate page tables and roots inside this buffer.
The page tables can always be read freely but modifications must go through
the kernel as arbitrary writes would compromise the security of the kernel.

To simplify security checks and avoid potential resource leaks,
the kernel uses a strict scheme:

- roots must be explicitly allocated (up to 512).
- parent page tables must be explicitly allocated.

The first root (0) is considered the default address space and used for
system calls in other address spaces.
