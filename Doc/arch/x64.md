x86-64 / x64 / AMD64 / IA32e
============================

Two types of kernels are provided:

- UEFI / BIOS compatible
- Unikernel (**TODO**)

The UEFI / BIOS kernel is intended for use on real hardware.

The unikernel is designed for "cloud" VPSes: small virtual machines
typically dedicated to a single application.

Only the UEFI/BIOS compatible kernels provide security and debugging tools.
The unikernel is designed to minimize overhead and to utilize debugging tools
provided by the hypervisor.

At least 10MiB of physical memory is required to be usable at all.
(first 2MiB reserved, 4MiB for the kernel and 4MiB for initial OS)


Supported hardware
------------------

- Memory
- MMU
- UART (COM1/COM2)
- PCI / PCIe (**TODO**)
- VirtIO (unikernel)
  - block (**TODO**)
  - net (**TODO**)


Initial OS
----------

The kernel can optionally load an OS at boot,
avoiding the need to start an OS through the serial link.

An address space is created with the following ranges defined:

- `0x3f000000` until `0x3f400000`: kernel code / data (RX[W])
- `0x3f800000` until `0x40000000`: page table (R)
- `0x3fe00000` until `0x40000000`: OS code (RX)

Note an OS starts with no data pages.
An OS should map in their own data pages.

The initial OS code is limited to at most 2MiB.
Extra code should be loaded externally.

The page table provides read-only access to the paging structure
currently in use. Updates can only be done through system calls.


System calls
------------

To efficiently support unikernels,
direct usage of the `syscall` instruction is prohibited.
Instead, all calls are proxied through routines mapped at
a fixed location.

System calls may use SSE registers.
To avoid leaking data or needing to save registers,
`vzeroall` (or equivalent) is always called before returning.


(Physical) memory allocation
----------------------------

By default, memory is divided in pages of 2MiB.
All memory allocations use whole 2MiB pages.
This makes it more convenient to use 2M pages in many places,
improving TLB performance.

It is likely many 4KiB pages are inaccessible by default with this scheme,
but this is not expected to be a significant issue.

Pages are only referenced in pages tables.
Pages can be referenced an arbitrary amount of times.

The allocation status of a page is tracked with a single bit.

Allocated pages are always recorded in the page table (even if unused/"not present").
Addresses of 4K pages are masked to refer to the containing 2M page.

To avoid needing to scan a potentially very large array (see table below)
pages are grouped in sets of 128 entries, each set having a 8-bit counter
indicating the number of free pages.

Additionaly, there are supersets of 256 entries each, each superset having
a 16-bit counter indicating the number of free pages.

### Tracing versus reference counting

Tracing GC is chosen because:

- It entirely avoids permanent resource leaks.
- It can seamlessly handle cyclic references.
- It potentially allows higher throughput by avoid random accesses to counters.

### Physical memory in bytes compared to page, set and superset count

| total physical memory | pages | sets | supersets |
| ---------------------:| -----:| ----:| ---------:|
|                   16M |     8 |    1 |         1 |
|                   32M |    16 |    1 |         1 |
|                   64M |    32 |    1 |         1 |
|                  128M |    64 |    1 |         1 |
|                  256M |   128 |    1 |         1 |
|                  512M |   256 |    2 |         1 |
|                    1G |   512 |    4 |         1 |
|                    2G |    1K |    8 |         1 |
|                    4G |    2K |   16 |         1 |
|                    8G |    4K |   32 |         1 |
|                   16G |    8K |   64 |         1 |
|                   32G |   16K |  128 |         1 |
|                   64G |   32K |  256 |         1 |
|                  128G |   64K |  512 |         2 |
|                  256G |  128K |   1K |         4 |
|                  512G |  256K |   2K |         8 |
|                    1T |  512K |   4K |        16 |
|                    2T |    1M |   8K |        32 |
|                    4T |    2M |  16K |        64 |
|                    8T |    4M |  32K |       128 |
|                   16T |    8M |  32K |       256 |
|                   32T |   16M |  64K |       512 |
|                   64T |   32M | 128K |        1K |
|                  128T |   64M | 256K |        2K |
|                  256T |  128M | 512K |        4K |
|                  512T |  256M |   1M |        8K |
|                    1P |  512M |   2M |       16K |
|                    2P |    1G |   4M |       32K |
|                    4P |    2G |   8M |       64K |

Note: a different strategy or a "super-superset" is likely prefereable above 1T.


MMU
---

The page tables used by the MMU are managed by the kernel.
The kernel initially allocates a single 2MiB buffer for the page table,
but more can be allocated in 2MiB chunks.

An OS can create multiple address spaces for isolation,
but only the initial address space is used for exceptions.

`syscall`s executed in other address spaces are always redirected to the
initial address space.

An OS must allocate page tables and roots inside this buffer.
The page tables can always be read freely but modifications must go through
the kernel as arbitrary writes would compromise the security of the kernel.

To simplify security checks and avoid potential resource leaks,
the kernel uses a strict scheme:

- roots must be explicitly allocated (up to 512).
- parent page tables must be explicitly allocated.

The first root (0) is considered the default address space and used for
system calls in other address spaces.
